const { join, dirname, relative } = require('path');
const { readdirSync, ensureDirSync, writeFileSync, lstatSync, existsSync } = require('fs-extra');
const rimraf = require('rimraf');
const chalk = require('chalk');

function resolveDir(dir) {
  if (!/\.(t|j)s$/.test(dir)) {
    return dir;
  }
  return dirname(dir);
}

function getPackage(rootPath) {
  // eslint-disable-next-line import/no-dynamic-require
  return require(join(rootPath, 'package.json'));
}

function getModuleDir(rootPath) {
  const pkg = getPackage(rootPath);
  try {
    return resolveDir(pkg.module);
  } catch (e) {
    // resolveDir will throw an error if pkg.module doesn't exist
    // we just return false here.
    return false;
  }
}

function getUnpkgDir(rootPath) {
  const pkg = getPackage(rootPath);
  try {
    return resolveDir(pkg.unpkg);
  } catch (e) {
    return false;
  }
}

function getTypesDir(rootPath) {
  const pkg = getPackage(rootPath);
  try {
    return resolveDir(pkg.types || pkg.typings);
  } catch (e) {
    return false;
  }
}

function getMainDir(rootPath) {
  const { main } = getPackage(rootPath);
  return resolveDir(main);
}

function removeExt(path) {
  return path.replace(/\.[^.]+$/, '');
}

function isRootModule(path, index, array) {
  const rootPath = path.replace(/^([^/]+).*$/, '$1');
  return path === rootPath || !array.includes(rootPath);
}

function isDirectory(path) {
  return lstatSync(path).isDirectory();
}

function getSourcePath(rootPath) {
  return join(rootPath, 'src');
}

function isPublicModule(rootPath, filename) {
  const isPrivate = /^_/.test(filename);
  if (isPrivate) {
    return false;
  }
  if (isDirectory(join(rootPath, filename))) {
    return true;
  }
  return /\.(j|t)sx?$/.test(filename);
}

function getPublicFiles(rootPath, prefix = '') {
  return readdirSync(rootPath)
    .filter(filename => isPublicModule(rootPath, filename))
    .reduce((acc, filename) => {
      const path = join(rootPath, filename);
      const childFiles = isDirectory(path) && getPublicFiles(path, join(prefix, filename));
      return {
        ...(childFiles || { [removeExt(join(prefix, filename))]: path }),
        ...acc
      };
    }, {});
}

function getProxyFolders(rootPath) {
  const publicFiles = getPublicFiles(getSourcePath(rootPath));
  return Object.keys(publicFiles)
    .map(name => name.replace(/\/index$/, ''))
    .filter(name => name !== 'index');
}

function getBuildFolders(rootPath) {
  return [
    getMainDir(rootPath),
    getUnpkgDir(rootPath),
    getModuleDir(rootPath),
    getTypesDir(rootPath),
    ...getProxyFolders(rootPath)
  ].filter(Boolean);
}

function cleanBuild(rootPath) {
  const pkg = getPackage(rootPath);
  const cleaned = [];
  getBuildFolders(rootPath)
    .filter(isRootModule)
    .forEach(name => {
      rimraf.sync(name);
      cleaned.push(chalk.bold(chalk.gray(name)));
    });
  if (cleaned.length) {
    console.log(['', `Cleaned in ${chalk.bold(pkg.name)}:`, `${cleaned.join(', ')}`].join('\n'));
  }
}

function getIndexPath(path) {
  return join(path, readdirSync(path).find(file => /^index\.(j|t)sx?/.test(file)));
}

function makeGitignore(rootPath) {
  const pkg = getPackage(rootPath);
  const buildFolders = getBuildFolders(rootPath);
  const contents = buildFolders
    .filter(isRootModule)
    .map(name => `/${name}`)
    .join('\n');
  writeFileSync(
    join(rootPath, '.gitignore'),
    `# Automatically generated by ${relative(rootPath, __filename)}\n${contents}\n`
  );
  console.log(`\nCreated in ${chalk.bold(pkg.name)}: ${chalk.bold(chalk.green('.gitignore'))}`);
}

function getProxyPackageContents(rootPath, moduleName) {
  const { name } = getPackage(rootPath);
  const mainDir = getMainDir(rootPath);
  const moduleDir = getModuleDir(rootPath);
  const typesDir = getTypesDir(rootPath);
  const prefix = '../'.repeat(moduleName.split('/').length);
  const json = {
    name: `${name}/${moduleName}`,
    private: true,
    sideEffects: false,
    main: join(prefix, mainDir, moduleName),
    ...(moduleDir ? { module: join(prefix, moduleDir, moduleName) } : {}),
    ...(typesDir ? { types: join(prefix, typesDir, moduleName) } : {})
  };
  return JSON.stringify(json, null, 2);
}

function makeProxies(rootPath) {
  const pkg = getPackage(rootPath);
  const created = [];
  getProxyFolders(rootPath).forEach(name => {
    ensureDirSync(name);
    writeFileSync(`${name}/package.json`, getProxyPackageContents(rootPath, name));
    created.push(chalk.bold(chalk.green(name)));
  });
  if (created.length) {
    console.log(['', `Created proxies in ${chalk.bold(pkg.name)}:`, `${created.join(', ')}`].join('\n'));
  }
}

function hasTSConfig(rootPath) {
  return existsSync(join(rootPath, 'tsconfig.json'));
}

module.exports = {
  getPackage,
  getModuleDir,
  getUnpkgDir,
  getTypesDir,
  getMainDir,
  getSourcePath,
  getPublicFiles,
  getProxyFolders,
  getBuildFolders,
  cleanBuild,
  getIndexPath,
  makeGitignore,
  makeProxies,
  hasTSConfig
};
